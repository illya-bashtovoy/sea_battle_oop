#include <iostream> 
#include <time.h> 
#include <windows.h> 
#include <conio.h> 
using namespace std;

// enum Перерахований тип
enum Color { Black, Blue, Green, Cyan, Red, Magenta, Brown, LightGray, DarkGray, LightBlue = 9, LightGreen, LightCyan, LightRed, LightMagenta, Yellow, White };
// Кольори якими можна фарбувати: колір тексту; колір заливки тексту
HANDLE hStdOut = GetStdHandle(STD_OUTPUT_HANDLE); // Дескриптор активного вікна
void setColor(Color text, Color background);
enum Napravlenie { Up = 72, Left = 75, Right = 77, Down = 80, Enter = 13, escepushka = 27, BackSpace = 8, Q = 113 };
// клавіші, звернутися до яких у коді можна через їхнє ім'я
void SetCursor(int x, int y);
struct Ships // структура характеристик кораблика
{
	int deck = { 0 }; // кількість палуб
	bool horizontal = true; // становище (спочатку - горизонтальне)
	bool alive = true; // перевірка на те, чи знищений кораблик чи ні
	int x, y; // Позиція кораблика по "x" і "y" (перша палуба), необхідна для правильного знищення кораблика
};

void explosion(Ships* characteristic, int ship_pos[12][24], int plus, int& end);
void LoadCharactShips(Ships* characteristic);
void auto_arrangement(Ships* characteristic, int ship_pos[12][24], int plus);
void PaintPos(int mas[12][24], int x, int num_color);
void Avake();
void CreatField(int speed, int X, int num_color);
void Paint(char variant[2][30], int T);
void Meny(int num);

int main() { 
	SetConsoleCP(1251);
	SetConsoleOutputCP(1251);
	srand(time(NULL)); 
	char variant[2][30] = { "АВТОМАТИЧНА РОЗСТАНОВКА","РУЧНА РОЗСТАНОВКА" };
	int ship_pos[12][24] = { 0 }; // двовимірний масив, завдяки якому можна буде відстежувати: 
	int enemy_ship_pos[12][24] = { 0 }; // двовимірний масив, завдяки якому можна буде відстежувати:
	/*
		0 - вільні місця (куди можна ставити)
		1 - позиції біля корабликів (куди не можна ставити)
		2 - місце куди потрапив снаряд, але де нічого не було
		3 - місце де був снаряд і був кораблик
		4 - 1-й палубний кораблик (1-ий)
		5 - 1-й палубний кораблик (2-ий)
		6 - 1-й палубний кораблик (3-ий)
		7 - 1-й палубний кораблик (4-ий)
		8 - 2-х палубний кораблик (1-ий)
		9 - 2-х палубний кораблик (2-ий)
		10 - 2-х палубний кораблик (3-ий)
		11 - 3-х палубний кораблик (1-ий)
		12 - 3-х палубний кораблик (2-ий)
		13 - 4-х палубний кораблик (перший та єдиний)
	*/
	Ships* characteristic = new Ships[20]; // створюємо 10 корабликів характеристики яких описані в структурі
	LoadCharactShips(characteristic); // завантаження характеристик корабликів (початкове положення та кількість палуб)
	int key = 1, y = 2, x = 2, num = 0, change = 1, A = 0, xx = 37, yy = 2, up = 0, down = 0, over = 0;
	bool manual_placement = true, your_turn = 0 + rand() % 2, start = false; // змінні для:
	/*
		key – змінна для запису натиснутої клавіші
		start - змінна для перевірки початку бою
		speed - швидкість промальовування ігрового поля
		А – додаткова змінна для меню
		SN - змінна для того, щоб запам'ятовувати який кораблі ми намагаємося добити.
		up - змінна, яка допоможе правильно добивати наші кораблики
		down - змінна яка допоможе правильно добивати наші кораблики
		xx - додаткова змінна для запису положення курсору на ворожому полі
		yy - додаткова змінна для запису положення курсору на ворожому полі
		y - позиція щодо Y
		x - позиція щодо X
		change - номер розміщення який буде використаний
		num - номер кораблкіа
		manual_placement - тип розміщення, який буде використаний
	*/
	Avake(); // Вадим напис "МОРСЬКИЙ БІЙ" на екран
	Sleep(1500); // чекаємо 1.5 секунд
	setColor(White, Black); // Встановлюємо колір тексту (білий на блакитному)
	system("cls"); //очищуємо консоль
	CreatField(1, 0, 9); //створюємо ігрове поле
	Paint(variant, change);
	do { //запускаємо цикл
		key = _getch(); //отримуємо номер натиснутої клавіші
		switch (key) { //запускаємо свитч
		case Up: //якщо натиснули "Стрілочка вгору"
			if (y > 0) { //якщо "y" більше 0
				y--; //віднімаємо від значення по "y" 1
				change = y; //вибраний пункт
				Paint(variant, change); //виведення пунктів на екран
			}
			break;
		case Down: //якщо натиснули "Стрілочка вниз"
			if (y < 1) { //якщо "y" менше 1
				y++; //додаємо до значення по "y" 1
				change = y; //вибраний пункт
				Paint(variant, change); //виведення пунктів на екран
			}
			break;
		case Enter:
			do {
				switch (change) {
				case 0: // якщо 0
					manual_placement = false; //автоматична расстанвкоа
					A++; //щоб завершити цикл
					break;
				case 1:
					manual_placement = true; //ручне розміщення
					A++; //щоб завершити цикл
					y++; //додаємо до значення по "y" 1
					break;
				}
			} while (key != Enter);
		}
	} while (A < 1);
	system("cls"); //очищуємо консоль
	CreatField(0, 0, 9); //створюємо ігрове поле
	x = 2, y = 2;
	if (manual_placement == false) { //якщо вібрано автоматичне розташування
		auto_arrangement(characteristic, ship_pos, 0); //передаємо необхідні значення для того, що автоматично розставити кораблки
		PaintPos(ship_pos, 2, 0); //перемальовуємо ігрову локацію з урахуванням внесених змін (поставили кораблик
		start = true; //починаємо гру
	}
	else if (manual_placement == true && num < 10) { //ручне розміщення
		do { //запускаємо цикл у якому при натисканні на ту чи іншу клавішу будеш робити ту чи іншу дію
			PaintPos(ship_pos, 2, 0); //перемальовуємо ігрову локацію з урахуванням внесених змін (поставили кораблик)
			SetCursor(x, y); //ставимо курсор на позицію змінних нижче змінних (X, Y)
			setColor(Black, Black); //встановлюємо чорний колір так як таким кольором виводитиметься кораблик
			if (characteristic[num].horizontal == true) { //якщо кораблик має горизонтальне положення
				for (size_t i = 0; i < characteristic[num].deck; i++) { //запускаємо цикл який малюватиме корабель з необхідною кількістю палуб
					cout << "++"; //2 "+" так як одна клітина в ширину в грі дорівнює 2-му клітинкам в ширину в консолі
				}
			}
			else if (characteristic[num].horizontal == false) {
				y += characteristic[num].deck; //змінюємо позицію по "y" на те, скільки палуб у кораблика
				for (size_t i = 0; i < characteristic[num].deck; i++) { //запускаємо цикл який малюватиме корабель з необхідною кількістю палуб
					cout << "++"; //2 "+" так як одна клітина завширшки у грі дорівнює двом клітинам завширшки в консолі
					y--; //спускаємось вниз на одну клітинку
					SetCursor(x, y); //встановлюємо позицію на одну клітинку нижче та на початкове за Х
				}
			}
			key = _getch();//функція повертає номер натиснутої кнопки
			switch (key) { //Виконуємо різні функції відповідно до натиснутої клавіші
			case Left: //якщо натиснули "Стрілочка вліво"
				if (x > 3) { //позиція до якої дозволено переміщення вліво
					x -= 2; //міняємо значення по Х на -2 так як одна клітинка у грі дорівнює двом у консолі
				}
				break;
			case Right: //якщо натиснули "Стрілочка вправо"
				if (characteristic[num].horizontal == true) //Якщо кораблик має горизонтальне положення
				{
					if (x < 22 - characteristic[num].deck * 2) { // перевіряємо не досяг він позиції до якої йому можна пересуватися (щоб він не вийшов за межі поля)
						x += 2; //міняємо значення змінної Х на +2 так як одна клітинка у грі дорівнює двом у консолі
					}
				}
				else { //Якщо кораблик має вертикальне положення
					if (x < 20) { // перевіряємо не досяг він позиції до якої йому можна пересуватися (щоб він не вийшов за межі поля)
						x += 2; //міняємо значення змінної Х на +2 так як одна клітинка у грі дорівнює двом у консолі
					}
				}
				break; //закрили цей кейс
			case Up: //якщо натиснули "Стрілочка вгору"
				if (y > 2) { //позиція, до якої дозволено переміщення вгору
					y--;  //міняємо значення Y на -1
				}
				break; //закрили цей кейс
			case Down: //якщо натиснули "Стрілочка вниз"
				if (characteristic[num].horizontal == false) { //Якщо кораблик має вертикальне положення
					if (y < 12 - characteristic[num].deck) {// перевіряємо не досяг він позиції до якої йому можна пересуватися (оскільки він 4-х палубний, і його необхідно обмежувати на 3 клітини раніше)
						y++;  //міняємо значення Y на +1
					}
				}
				else {
					if (y < 11) { // перевіряємо не досяг він позиції до якої йому можна пересуватися (щоб він не вийшов за межі поля)
						y++;  //міняємо значення Y на +1
					}
				}
				break; //закрили цей кейс
			case Q: //якщо натиснули "Q"
				characteristic[num].horizontal = !characteristic[num].horizontal; //змінити орієнтацію кораблика на протилежну
				if (characteristic[num].horizontal == false && y + characteristic[num].deck >= 13) {
					//перевіряємо чи зачепити кораблик кордон по вертикалі при перевороті, якщо його не відсунути
					y -= y + characteristic[num].deck - 12; //якщо так, то заздалегідь змінимо його положення, щоб він не пройшов сковзь межі поля по вертикалі.
				}
				else if (characteristic[num].horizontal == true && x + characteristic[num].deck * 2 >= 24) {
					//перевіряємо чи зачепити кораблик кордон по вертикалі при перевороті, якщо його не відсунути
					x -= (x + characteristic[num].deck * 2) - 22; //якщо так, то заздалегідь змінимо його положення, щоб він не пройшов сковзь межі поля по вертикалі.
				}
				for (size_t i = 0; i < 10 - num; i++) { //змінюємо орієнтацію так само і для наступних корабликів
					characteristic[num + i].horizontal = characteristic[num].horizontal; // заздалегідь змінюємо положення наступного кораблика на те, що ми вибрали зараз
				}
				break; //закрили цей кейс
			case Enter: //якщо натиснули "Enter"
				if (characteristic[num].horizontal == true && ship_pos[y - 1][x] == 0 && ship_pos[y - 1][x + characteristic[num].deck * 2 - 2] == 0) {
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < 3; q++) { //виконеям нижчезазначений код 3 рази так як нам необхідно окупувати кораблик щоб вони не стояли повною один до одного
						for (size_t w = 1; w < characteristic[num].deck * 3 + 1; w++) { //виконеям нижчезазначений код 11 разів так як треба щоб 4-х палубний кораблик повністю окуповувався
							ship_pos[y - 2 + q][x - 3 + w] = 1; //міняємо значення окупованих позицій у двовимірному масиві який будемо перевіряти на різні цифри, на "1"
						}
					}
					for (int g = 0; g < 2 * characteristic[num].deck; g++) { //виконеям нижчезазначений код 8 разів тому що кораблик 4-х палубний, а одна палуба по горизонаталі 2 клітинки
						ship_pos[y - 1][x + g] = 13 - num;  //міняємо значення позицій у двомірному масиві який будемо перевіряти на різні цифри, на "2"
					}
					num++; //переходимо до наступного кораблика
				}
				if (characteristic[num].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + characteristic[num].deck - 2][x] == 0) {
					characteristic[num].x = x + 2, characteristic[num].y = y;
					for (size_t q = 0; q < characteristic[num].deck + 2; q++) { //виконеям нижчезазначений код 6 разів тому що нам необхідно окупувати кораблик, щоб вони не стояли повною один до одного
						for (size_t w = 0; w < 6; w++) { //виконеям нижчезазначений код 6 разів тому що нам необхідно окупувати кораблик, щоб вони не стояли повною один до одного
							ship_pos[y - 2 + q][x - 2 + w] = 1; //міняємо значення окупованих позицій у двовимірному масиві який будемо перевіряти на різні цифри, на "1"
						}
					}
					for (int g = 0; g < characteristic[num].deck; g++) { //виконеям нижчезазначений код 3 рази так як кораблик 3-х палубний
						for (int n = 0; n < 2; n++) { //виконуємо нижчевказаний код 2 рази оскільки нам необхідно змінити закінчення в масиві для двох клітин (однієї палуби)
							ship_pos[y - 1 + g][x + n] = 13 - num; //міняємо значення позицій у двомірному масиві який будемо перевіряти на різні цифри, на "2"
						}
					}
					num++; //переходимо до наступного кораблика
				}
			}
			start = true;//запускаємо гру
		} while (num <= 9); //цикл працює до тих пір, поки кількість розставлених корабликів не дорівнює 10
	}
	Sleep(20);
	CreatField(1, 35, 4); //створюємо ігрове поле
	auto_arrangement(characteristic, enemy_ship_pos, 10); //автоматичне розміщення для ворожих корабликів
	PaintPos(enemy_ship_pos, 37, 15); //малювання ворожих кораблів/поля
	do {
		if (your_turn == true) { //якщо моя черга атакувати
			do { //запускаємо цикл у якому при натисканні на ту чи іншу клавішу будеш робити ту чи іншу дію
				x = xx, y = yy; //змінна яка запам'ятовуватиме де знаходився курсор
				PaintPos(enemy_ship_pos, 37, 15); //перемальовуємо ігрову локацію з урахуванням внесених змін (поставили кораблик)
				setColor(DarkGray, DarkGray); //встановлюємо чорний колір так як таким кольором виводитиметься кораблик
				SetCursor(x, y); //ставимо курсор на позицію змінних нижче змінних (X, Y)
				cout << "++"; //2 "+" так як одна клітина в ширину в грі дорівнює 2-му клітинкам в ширину в консолі
				key = _getch();//функція повертає номер натиснутої кнопки
				switch (key) { //Виконуємо різні функції відповідно до натиснутої клавіші
				case Left: //якщо натиснули "Стрілочка вліво"
					if (x > 38) {//позиція до якої дозволено переміщення вліво
						x -= 2; //міняємо значення по Х на -2 так як одна клітинка у грі дорівнює двом у консолі
						xx = x; //запам'ятовуємо становище курсору
					}
					break;
				case Right: //якщо натиснули "Стрілочка вправо"
					if (x < 55) { // перевіряємо не досяг він позиції до якої йому можна пересуватися (щоб він не вийшов за межі поля)
						x += 2; //міняємо значення змінної Х на +2 так як одна клітинка у грі дорівнює двом у консолі
						xx = x; //запам'ятовуємо становище курсору
					}
					break; //закрили цей кейс
				case Up: //якщо натиснули "Стрілочка вгору"
					if (y > 2) { //ппозиція до якої дозволено переміщення вгору
						y--;  //міняємо значення Y на -1
						yy = y; //запам'ятовуємо становище курсору
					}
					break; //закрили цей кейс
				case Down: //якщо натиснули "Стрілочка вниз"
					if (y < 11) { //позиція, до якої дозволено переміщення вниз
						y++;  //міняємо значення Y на +1
						yy = y; //запам'ятовуємо становище курсору
					}
					break;
				case Enter:
					if (enemy_ship_pos[y - 1][x - 35] >= 4) { //перевірити позицію за якою ми стрільнули на наявність корабликів
						for (size_t i = 0; i < 2; i++) { //якщо це так то ми замінюємо у клітинці номерок кораблика на "3"
							enemy_ship_pos[y - 1][x - 35 + i] = 3; // змінюємо значення
							explosion(characteristic, enemy_ship_pos, 10, over); //перевіряємо на знищення
						}
						Meny(9); //виведення репліки на екран
						Sleep(500); //невелика пауза
					}
					else if (enemy_ship_pos[y - 1][x - 35] < 2) { //Якщо на позиції, за якою був вогонь, нічого немає
						for (size_t i = 0; i < 2; i++) { //якщо це так то ми замінюємо в клітинці номерок кораблика на "2"
							enemy_ship_pos[y - 1][x - 35 + i] = 2; // змінюємо значення
						}
						Sleep(500); //невелика пауза
						Meny(5); //виведення репліки на екран
						your_turn = false; //черга атаки супротивника
					}
					break;
				}
			} while (key != Enter); //виконувати код який демонструється в цикл доти, доки не натиснута клавіша "Enter"
		}
		if (your_turn == false) { //якщо хід супротивника
			Sleep(0 + rand() % 400); //невелика пауза
			Meny(0); //виведення репліки на екран
			PaintPos(ship_pos, 2, 0); //перемальовуємо наше поле
			Sleep(0 + rand() % 400); //невелика пауза
			x = (2 + rand() % 10) * 2, y = 2 + rand() % 10; //випадковим чином видаємо координату, за якою відбуватиметься атака
			if (ship_pos[y - 1][x - 1] >= 4) { //перевірити позицію за якою ми стрільнули на наявність корабликів
				for (size_t i = 0; i < 2; i++) { //якщо це так то ми замінюємо у клітинці номерок кораблика на "3"
					ship_pos[y - 1][x - 2 + i] = 3;  // змінюємо значення
					explosion(characteristic, ship_pos, 0, over); //перевіряємо на знищення
				}
				Meny(2); //виведення репліки на екран
				Sleep(0 + rand() % 750); //невелика пауза
			}
			else if (ship_pos[y - 1][x - 1] <= 2) { //Якщо на позиції, за якою був вогонь, нічого немає
				for (size_t i = 0; i < 2; i++) { //якщо це так то ми замінюємо в клітинці номерок кораблика на "2"
					ship_pos[y - 1][x - 2 + i] = 2; //змінюємо значення
				}
				Meny(1); //виведення репліки на екран
				Sleep(0 + rand() % 750); //невелика пауза
				your_turn = true; //моя черга атаки
			}
		}
	} while (over == 0);
	PaintPos(ship_pos, 2, 0);
	PaintPos(enemy_ship_pos, 37, 15); //перемальовуємо ігрову локацію з урахуванням внесених змін (поставили кораблик)
	if (over == 2) {
		Meny(7);
	}
	else {
		Meny(3);
	}
	Sleep(500000);
}
void setColor(Color text, Color background) { //функція, за допомогою якої відбувається зміна кольору тексту
	SetConsoleTextAttribute(hStdOut, (WORD)((background << 4) | text)); //встановлення параметрів тексту
}
void SetCursor(int x, int y) { //функція для того, щоб встановлювати позицію курсора в консолі по осі Х та Y
	COORD myCoords = { x,y }; //ініціалізація координат
	SetConsoleCursorPosition(hStdOut, myCoords); //Спосіб переміщення курсору на потрібні координати
}
void explosion(Ships* characteristic, int ship_pos[12][24], int plus, int& end) { //знищення корабліків та визначення переможця у грі
	int A = 0; //змінна для правильної замальовки кордону навколо кораблика
	int B = 13; //змінна, яка допомагатиме вказувати на потрібний кораблик
	int C = 0; //змінна, яка зберігає кількість знищених корабликів (якщо = 10, то гра завершується)
	bool alive = false; //змінна за допомогою якої ми перевірятимемо знищення корабликів
	for (size_t n = 13; n > 3; n--) { //перевіряємо всі номери корабликів на наявність їх у масиві
		for (size_t i = 1; i < 11; i++) { //проганяємо масив по рядках
			for (size_t r = 2; r < 22; r++) { //проганяємо масив стовпцями
				if (ship_pos[i][r] == n) { //перевіряємо, чи є в масиві хоч один номерок із корабликом
					alive = true; //у разі успіху - кораблик живий/поранений
					i = 11; //міняємо значення щоб перейти до наступного номера
					break; //виходимо з циклу
				}
			}
		}
		if (alive == false) { //якщо номерок знайдено не був, то кажемо, що кораблик якому було присвоєно цей номер знищено
			characteristic[B - n + plus].alive = false; //говоримо, що даний кораблик знищений
		}
		else { 
			alive = false; //змінюємо цю змінну на "false", щоб перевірити наступний кораблик
		}
	}
	for (size_t i = plus; i < 10 + plus; i++) { //запускаємо цикл, у якому перевірятимемо всі кораблики однієї команди на знищення
		if (i == 0 || i == 10) { //для 4-х палубних
			A = 0; //змінюємо значення змінної для правильного малювання
		}
		else if (i == 1 || i == 2 || i == 11 || i == 12) { //для 3-х палубних
			A = 1; //змінюємо значення змінної для правильного малювання
		}
		else if (i > 2 && i < 6 || i > 12 && i < 16) { //для 2-х палубних
			A = 2; //змінюємо значення змінної для правильного малювання
		}
		else { //для 1-о палубних
			A = 3; //змінюємо значення змінної для правильного малювання
		}
		if (characteristic[i].alive == false) { //якщо цей кораблик знищено
			if (characteristic[i].horizontal == true) { //якщо він має горизонтальне положення
				for (size_t q = 0; q < 3; q++) { //виконеям нижчезазначений код 3 рази так як нам необхідно окупувати кораблик щоб вони не стояли повною один до одного
					for (size_t w = 0; w < characteristic[i].deck * 3 + A; w++) { //виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб "окупувати" знищений кораблик
						ship_pos[characteristic[i].y - 2 + q][characteristic[i].x - 4 + w] = 2; //міняємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "2" (промах)
					}
				}
				for (size_t g = 0; g < 2 * characteristic[i].deck; g++) { //виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб виділити знищений кораблик
					ship_pos[characteristic[i].y - 1][characteristic[i].x - 2 + g] = 3; //міняємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "3" (подання)
				}
			}
			else if (characteristic[i].horizontal == false) {  //якщо він має вертикальне положення
				for (size_t q = 0; q < characteristic[i].deck + 2; q++) { //виконеям нижчезазначений код 3 рази так як нам необхідно окупувати кораблик щоб вони не стояли повною один до одного
					for (int w = -4; w < 2; w++) { //виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб "окупувати" знищений кораблик
						ship_pos[characteristic[i].y - 2 + q][characteristic[i].x + w] = 2; //міняємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "2" (промах)
					}
				}
				for (int g = 0; g < characteristic[i].deck; g++) { //виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб виділити знищений кораблик
					for (int n = -2; n < 0; n++) { //виконуємо нижчезазначений код 2 рази тому що нам необхідно змінити значення в масиві для двох клітин (однієї палуби)
						ship_pos[characteristic[i].y - 1 + g][characteristic[i].x + n] = 3; //міняємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "3" (подання)
					}
				}
			}
			C++; 
		}
	}
	if (C == 10 && plus == 0) { //якщо всі наші кораблики знищені
		end = 1; //завершуємо гру (ураження)
	}
	else if (C == 10 && plus == 10) { //якщо всі кораблики ворога знищені
		end = 2; //завершуємо гру (перемога)
	}
	else { 
		C = 0; //онулдуємо лічильник знищених корабликів
	}
}
void LoadCharactShips(Ships* characteristic) { //присвоєння палуб відповідно до номера кораблика
	for (size_t i = 0; i < 20; i++) { //виконанням вказаний код 20 разів так як загальна кількість корабликів дорівнює 20
		if (i == 0 || i == 10) { //для 4-х палубних
			characteristic[i].deck = 4; //робимо кораблик з 4-ма палубами
		}
		else if (i > 0 && i <= 2 || i > 10 && i <= 12) { //для 3-х палубних
			characteristic[i].deck = 3; //робимо кораблик  з 3-ма палубами
		}
		else if (i > 2 && i <= 5 || i > 12 && i <= 15) {//для 2-х палубних
			characteristic[i].deck = 2; //робимо кораблик  з 2-ма палубами
		}
		else if (i > 5 && i <= 9 || i > 15 && i <= 19) { ///для 1-о палубних
			characteristic[i].deck = 1; //робимо кораблик  з 1-ой палубой
		}
	}
}
void auto_arrangement(Ships* characteristic, int ship_pos[12][24], int plus) { //Автоматичне розміщення корабликів
	int y, x, ship = plus; //змінна для координат та номера кораблика
	while (ship < plus + 10) { //виконуємо нижчезазначений код доти, доки не будуть розставлені всі 10 корабликів
		characteristic[ship].horizontal = 0 + rand() % 2; //привласнюємо рандомну орієнтацію
		y = 2 + rand() % 9, x = (1 + rand() % 9) * 2; //надають рандкові координати (в рамках ігрової зони)
		if (characteristic[ship].horizontal == false && y + characteristic[ship].deck >= 13) {
			//перевіряємо чи зачепити кораблик кордон по вертикалі при перевороті, якщо його не відсунути
			y -= y + characteristic[ship].deck - 12; //якщо так, то заздалегідь змінимо його положення, щоб він не пройшов сковзь межі поля по вертикалі.
		}
		else if (characteristic[ship].horizontal == true && x + characteristic[ship].deck * 2 >= 24) {
			//перевіряємо чи зачепити кораблик кордон по вертикалі при перевороті, якщо його не відсунути
			x -= (x + characteristic[ship].deck * 2) - 22; //якщо так, то заздалегідь змінимо його положення, щоб він не пройшов сковзь межі поля по вертикалі.
		}
		if (characteristic[ship].horizontal == true && ship_pos[y - 1][x] == 0 && ship_pos[y - 1][x + characteristic[ship].deck * 2 - 2] == 0) {
			// перевіря чи має кораблик горизонтальне положення і чи немає нічого на позиціях куди він буде встановлюватися
			characteristic[ship].x = x + 2, characteristic[ship].y = y; //запам'ятовуємо координати першої палуби у кожного кораблика, щоб надалі правильно їх підривати
			for (size_t q = 0; q < 3; q++) { //виконеям нижчезазначений код 3 рази так як нам необхідно "окупувати" кораблик щоб вони не стояли повною один до одного
				for (size_t w = 1; w < characteristic[ship].deck * 3 + 1; w++) {//виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб "окупувати" знищений кораблик
					ship_pos[y - 2 + q][x - 3 + w] = 1;  //змінюємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "1" (окупована позиція живого кораблика)
				}
			}
			for (int g = 0; g < 2 * characteristic[ship].deck; g++) { //виконеям нижчезазначений код потрібну кількість разів (для кожного окремо рахуємо), щоб виділити знищений кораблик
				ship_pos[y - 1][x + g] = 13 - ship + plus;  //міняємо значення позицій у двомірному масиві який будемо перевіряти на різні цифри, на "4-13" (номери корабликів (у кожного свій))
			}
			ship++; //переходимо до наступного кораблика
		}
		if (characteristic[ship].horizontal == false && ship_pos[y - 1][x] == 0 && ship_pos[y + characteristic[ship].deck - 2][x] == 0) {
			// перевіря чи має кораблик горизонтальне положення і чи немає нічого на позиціях куди він буде встановлюватися
			characteristic[ship].x = x + 2, characteristic[ship].y = y;//запам'ятовуємо координати першої палуби у кожного кораблика, щоб надалі правильно їх підривати
			for (size_t q = 0; q < characteristic[ship].deck + 2; q++) {
				for (size_t w = 0; w < 6; w++) {
					ship_pos[y - 2 + q][x - 2 + w] = 1; //змінюємо значення "окупованих" позицій у двомірному масиві який будемо перевіряти на різні цифри, на "1" (окупована позиція живого кораблика)
				}
			}
			for (int g = 0; g < characteristic[ship].deck; g++) {
				for (int n = 0; n < 2; n++) { //виконуємо нижчевказаний код 2 рази оскільки нам необхідно змінити закінчення в масиві для двох клітин (однієї палуби)
					ship_pos[y - 1 + g][x + n] = 13 - ship + plus; //міняємо значення позицій у двомірному масиві який будемо перевіряти на різні цифри, на "4-13" (номери корабликів (у кожного свій))
				}
			}
			ship++; //переходимо до наступного кораблика
		}
	}
}
void PaintPos(int mas[12][24], int x, int num_color) { //промальовування ігрової карти відповідно до положення поставлених корабликів
	for (size_t i = 1; i < 11; i++) { //виконанням вказаний код 10 разів так як загальна кількість рядків дорівнює 10
		int y = 1 + i; //встановлюємо координати за умовчанням 2 по Х і 2 по Y так як малювання поля має починатися там
		SetCursor(x, y); //переміщуємо курсор на вищезазначені позиції

		for (size_t g = 2; g < 22; g++) {//виконеям нижчезазначений код 20 разів так як загальна кількість стовпців дорівнює 20
			if (mas[i][g] == 2) { //якщо в масиві на цьому місці знаходиться "2"
				setColor(LightGray, LightGray); //малюємо сіру клітинку
			}
			else if (mas[i][g] == 3) { //якщо у масиві на цьому місці знаходиться "3"
				setColor(LightMagenta, LightMagenta); //малюємо клітинку незрозумілого кольору
			}
			else if (mas[i][g] >= 4) { //якщо у масиві на цьому місці знаходиться "4+"
				setColor(Color(num_color), Color(num_color)); //встановлюємо колір корабликів (наші – чорні / ворога – білі)
			}
			else { //в інших випадках малюємо білу клітинку
				setColor(White, White); //встановлюємо білий колір оскільки таким кольором буде ігрова локація на якій будуть відбуватися основні дії
			}
			cout << "+"; //малюємо будь-який знак, через забарвлення він буде квадратиком
		}
		cout << "\n"; //перехід на новий рядок при відображенні одного рядка повністю
	}
}
void Avake() { //функція яка буде показана гравцеві найперша
	setColor(Yellow, LightBlue); //Встановлюємо колір тексту
	SetCursor(24, 12); //встановлюємо позицію курсору (на власний розсуд)
	cout << "МОРСЬКИЙ БІЙ" << endl;
	SetCursor(25, 13);
	cout << "російський військовий корабель" << endl;
	SetCursor(26, 14);
	cout << "*** *****" << endl;
}
void CreatField(int speed, int X, int num_color) { //Функція добродії якої буде відображатись ігрове поле
	SetCursor(X, 1); //Встановлюємо курсор на потрібну позицію
	char mas[10] = { 'A','B','C','D','E','F','G','H','I','J' }; //літери які будуть зверху ігрового поля та орієнтувати гравця куди він б'є
	setColor(White, Color(num_color)); //Зміна кольору (літера - білий; заливка - червоний/синій)
	int A = 0, B = 0; //змінні необхідні для правильного відображення ігрового поля
	cout << "  " << mas[0]; //За допомогою цього друкуємо букву "А" і ставимо на початку пробіл, щоб було рівненько і красиво.
	for (size_t i = 0; i < 12; i++) { //виконеям нижчезазначений код 12 разів так як загальна кількість рядків дорівнює 12
		if (B == 0) { //геніальна перевірка, яка спрацює один раз
			SetCursor(X + 3, 1 + i); //Встановлюємо курсор на потрібну позицію
			B++; //збільшуємо значення змінної
		}
		else { 
			SetCursor(X, 1 + i);  //Встановлюємо курсор на потрібну позицію
		}
		for (size_t g = 0; g < 23; g++) { //виконеям нижчезазначений код 23 разів так як загальна кількість стовпців дорівнює 23
			if (i == 0 && g == 22) { //виконуємо вищевказаний код, якщо ми на першому рядку, та 22 елементі
				setColor(Color(num_color), Color(num_color)); //Змінюємо колір тексту та заливки на червоний/синій (кордони поля на яких немає цифр або букв)
				Sleep(speed); //Затримка, щоб була анімація
				cout << '+'; //малюємо будь-який знак, через забарвлення він буде квадратиком
			}
			if (i == 0 && g > 0 && g < 10) { //виконуємо вищевказаний код, якщо ми на першому рядку, і в діапозоні з 0-го по 10-ий елемент
				setColor(White, Color(num_color)); //Зміна кольору (літера - білий; заливка - червоний/синій)
				Sleep(speed); //Затримка, щоб була анімація
				cout << " " << mas[g]; //Пишемо пробіл, і букву яка стоїть на місці елемента номер якого дорівнює значенню "g"
			}
			else if (i > 0 && i < 11 && g == 0) { //Інакше якщо ми знаходимося з 0-го по 11-ий рядок на 0-му елементі
				setColor(White, Color(num_color)); //Зміна кольору (літера - білий; заливка - червоний/синій)
				if (i < 10) {//Якщо ми знаходимося на рядках, що не досягають значення "10"
					Sleep(speed); //Затримка, щоб була анімація
					cout << i << ' '; //Пишемо цифру, яка вказує на номер рядка, яка допомагатиме гравцеві орієнтуватися, куди він стріляє () для того, щоб було рівно по співвідношенню з двозначними цифрами.
				}
				else { 
					Sleep(speed); //Затримка, щоб була анімація
					cout << i; //Пишемо цифру без прогалин тому що тут вони не будуть потрібні адже цифра яка буде виводитися "10"
				}
			}
			else if (i == 11 || g > 20 && g < 23) { //Інакше якщо ми знаходимося на 11-му рядку, на 21-22 елементах
				if (A == 0 && i == 11) { //перевірка на останньому рядку, яка потрібна щоб виводився кубик, який не виводиться самостійно
					Sleep(speed); //Затримка, щоб була анімація
					cout << "+";//малюємо будь-який знак, через забарвлення він буде квадратиком
					A++; //міняємо значення змінної завдяки якій можна було реалізувати домальовування потрібного кубика
				}
				setColor(Color(num_color), Color(num_color)); //Змінюємо колір тексту та заливки на червоний/синій (кордони поля на яких немає цифр або букв)
				Sleep(speed); //Затримка, щоб була анімація
				cout << '+'; //малюємо будь-який знак, через забарвлення він буде квадратиком
			}
			else if (i > 0) { //якщо ми знаходимося на рядку номер якого не дорівнює "0" (безпосередньо ігрове поле)
				Sleep(speed); //Затримка, щоб була анімація
				setColor(White, White); //Змінюємо колір тексту та заливки на білий (безпосередньо ігрове поле)
				cout << '+'; //малюємо будь-який знак, через забарвлення він буде квадратиком
			}
		}
	}
	setColor(Black, Black); //встановлюємо повністю чорний колір
}
void Paint(char variant[2][30], int T) { //меню вибору розміщення
	system("cls"); //очищаємо консоль
	for (size_t i = 0; i < 2; i++) { //створюємо цикл для двох елементів
		SetCursor(30, 6 + i); //Встановлюємо курсор на потрібну позицію
		for (size_t p = 0; p < 30; p++) { //створюємо цикл для всіх 30-ти літер
			if (i == T) { //перевірка на вибраний пункт
				setColor(Black, White); //виділяємо вибраний пункт
			}
			else { 
				setColor(White, Black); //прибираємо виділення вибраного пункту
			}
			cout << variant[i][p]; //виводимо пункти у вигляді тексту
		}
	}
	CreatField(0, 0, 9); //створюємо ігрове поле наново
}
void Meny(int num) {
	char variant[18][40] = { "ПАРАШКА ДУМАЄ КУДИ УДАРИТИ...","ПАРАШКА ПРОМАЗАЛА!", "ПАРАШКА ВЛУЧИЛА!", "НАШУ ТЕХНІКУ ЗНИШІЛИ! =( ", "ТВІЙ ХІД." , "БАЙРАКТАР НЕ ВЛУЧИВ...", "БАЙРАКТАР ВЛУЧИВ!", "УКРАЇНА ПЕРЕМОГЛА, ВІТАЮ!", "+++++++++++++++++++++++++++++++++++++++", "ВЛУЧИВ, ДОБИЙ КОРАБИЛЬ!", "ЮХУ, ТИ ЗНИШІВ КОРАБИЛЬ ПАРАШКИ!" };
	//список варіантів реплік, які можуть вивестися під час гри
	SetCursor(22, 18); //Встановлюємо курсор на потрібну позицію
	setColor(Black, Black); //встановлюємо повністю чорний колір
	for (size_t i = 0; i < 25; i++) { //цикл для стирання попереднього тексту
		cout << variant[10][i]; //виводимо "+"
		cout << variant[10][i]; //виводимо "+"
	}
	SetCursor(22, 18); //Встановлюємо курсор на потрібну позицію
	if (num > 0 && num < 4) { //перевіряємо, якщо репліки більше відносяться до ворога
		setColor(Red, Black); //Встановлюємо червоний колір тексту на чорному тлі
	}
	else { //інакше репліки більше відносяться до мене
		setColor(Green, Black); //Встановлюємо зелений колір тексту на чорному тлі
	}
	for (size_t i = 0; i < 30; i++) { //створюємо цикл для всіх 30-ти літер
		cout << variant[num][i];  //виводимо репліки у вигляді тексту
	}
}
